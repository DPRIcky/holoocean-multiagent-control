import numpy as np

class fin:
    '''
    Represents a fin for hydrodynamic calculations.

    INPUTS:
        a:      fin area (m^2)
        CL:     coefficient of lift (dimensionless)
        x:      x distance (m) from center of vehicle (negative for behind COM)
        c:      radius (m) from COP on the fin to the COM in the YZ plane
        angle:  offset of fin angle around x axis (deg) starting from positive y
                0 deg: fin on starboard side 
                90 deg: fin on bottom
        rho:    density of fluid (kg/m^3) 
    
    Coordinate system: Right-handed, x-forward, y-starboard, z-down
    '''
    
    def __init__(
            self,
            a,
            CL,
            x,
            c = 0,
            angle = 0,
            rho = 1026,  # Default density of seawater
            T_delta = 0.1,
            deltaMax = 15, # max deflection in degrees
    ):
        # fix NED
        self.area = a  # Fin area (m^2)
        self.CL = CL   # Coefficient of lift (dimensionless)
        self.angle_rad = np.deg2rad(angle)  
        self.rho = rho  # Fluid density (kg/m^3)

        self.u_actual = 0.0  #Actual position of the fin (rad)
        self.T_delta = T_delta              # fin time constant (s) 
        self.deltaMax = np.deg2rad(deltaMax) # max fin angle (rad)

        # Calculate fin's Center of Pressure (COP) position relative to COB
        y = np.cos(self.angle_rad) * c  # y-component of COP (m)
        z = np.sin(self.angle_rad) * c  # z-component of COP (m)
        self.R = np.array([x, y, z])    # Location of COP of the fin relative to COB (m)

    def velocity_in_rotated_plane(self, nu_r):
        """
        Calculate velocity magnitude in a plane rotated around the x-axis.

        Parameters:
            nu_r (numpy array): Velocity vector [vx, vy, vz] (m/s) in ENU frame

        Returns:
            float: Magnitude of velocity (m/s) in the rotated plane.
        """
        # Extract velocity components
        vx, vy, vz = nu_r  # m/s

        # Rotate y component around x-axis to align with fin plane
        vy_rot = np.sqrt((vy * np.sin(self.angle_rad))**2 + (vz * np.cos(self.angle_rad))**2)

        # Calculate magnitude in the rotated plane (x, y')
        U_plane = np.sqrt(vx**2 + vy_rot**2)

        return U_plane  # m/s

    def tau(self, nu_r,  nu):
        """
        Calculate force vector generated by the fin.

        Parameters:
            nu_r (numpy array): Relative velocity [vx, vy, vz, p, q, r] 
                              (m/s for linear, rad/s for angular)
            nu (numpy array): Velocity [vx, vy, vz, p, q, r] 
                              (m/s for linear, rad/s for angular) 

        Returns:
            numpy array: tau vector [Fx, Fy, Fz, Tx, Ty, Tz] (N) and (N*m) in body-fixed frame
        """        
        ur = self.velocity_in_rotated_plane(nu_r[:3])  # Calculate relative velocity in plane of the fin
        
        print(ur)
        print(f"rho: {self.rho}")
        print(f"area: {self.area}")
        print(f"CL: {self.CL}")
        print(f"u_actual: {self.u_actual}")
        # Calculate lift force magnitude
        f = 0.5 * self.rho * self.area * self.CL * self.u_actual * ur**2  # N

        print(f)

        # Decompose force into y and z components
        fy = np.sin(self.angle_rad) * f  # N
        fz = -np.cos(self.angle_rad) * f  # N 
        print(f"{fy}, {fz}")

        F = np.array([0, fy, fz])  # Force vector (N)

        # Calculate torque using cross product of force and moment arm
        torque = np.cross(self.R, F)  # N*m
        return np.append(F, torque)
    
    def actuate(self, sampleTime, command):
        # Actuator dynamics        
        delta_dot = (command - self.u_actual) / self.T_delta  
        self.u_actual += sampleTime * delta_dot  # Euler integration 

        # Amplitude Saturation
        if abs(self.u_actual) >= self.deltaMax:
            self.u_actual = np.sign(self.u_actual) * self.deltaMax

    
    def calculate_deflection(self, desired_torque, nu_r):
        """
        Calculate the fin deflection needed to apply a specific torque on the vehicle.

        Parameters:
            desired_torque (float): Desired torque vector [Tx, Ty, Tz] (N*m) in body-fixed frame
            nu_r (numpy array): Relative velocity [vx, vy, vz, p, q, r] 
                                (m/s for linear, rad/s for angular)

        Returns:
            float: Required fin deflection (radians)
        """
        
        ur = self.velocity_in_rotated_plane(nu_r[:3])  # Calculate relative velocity in plane of the fin
        
        if desired_torque[1] != 0 and desired_torque[2] == 0:
            # Torque about y-axis - desired force in z
            torque = desired_torque[1]
            force = -torque / (self.R[0] * -np.cos(self.angle_rad))   # Negated Because it is RxF not R*F
        elif desired_torque[2] != 0 and desired_torque[1] == 0:
            # Torque about z-axis - desired force in y
            torque = desired_torque[2]
            force = torque / (self.R[0] * np.sin(self.angle_rad))
        elif desired_torque[1] == 0 and desired_torque[2] == 0:
            force = 0
        else:
            raise ValueError("Only one of Ty or Tz should be non-zero")
        
        # Calculate the required deflection
        den = (0.5 * self.rho * self.area * self.CL * ur**2)
        if den > 0:
            required_deflection = force / den
        else:
            required_deflection = 0
        
        # Ensure the deflection is within reasonable limits 
        required_deflection = np.clip(required_deflection, -self.deltaMax, self.deltaMax)
        
        return required_deflection



class thruster:
    '''
    Represents a thruster for hydrodynamic calculations.

    Default values are for a single-screw propeller with 3 blades and blade-area ratio = 0.718.
    Similar to a REMUS 100 thruster.

    INPUTS:
        rho:    density of fluid (kg/m^3) 
    
    Coordinate system: Right-handed, x-forward, y-starboard, z-down
    '''
    def __init__(self, 
        T_n=1.0,
        nMax=1525,
        rho=1026,
        D_prop=0.14,
        t_prop=0.1,
        KT_0=0.4566,
        KQ_0=0.0700,
        KT_max=0.1798,
        KQ_max=0.0312,
        w=0.056,
        Ja_max=0.6632
        ):
        # Actuator dynamics
        self.u_actual = 0.0           # actual rpm of the thruster
        self.rho = rho

        # Propeller parameters
        self.nMax = nMax                # max propeller revolution (rpm)    
        self.T_n = T_n                  # propeller time constant (s)
        self.D_prop = D_prop            # propeller diameter (m)
        self.t_prop = t_prop            # thrust deduction number
        self.KT_0 = KT_0                # thrust coefficient at zero advance ratio
        self.KQ_0 = KQ_0                # torque coefficient at zero advance ratio
        self.KT_max = KT_max            # max thrust coefficient
        self.KQ_max = KQ_max            # max torque coefficient
        self.w = w                      # propeller wake fraction
        self.Ja_max = Ja_max            # max advance ratio

    def tau(self, nu_r, nu):
        """
        Calculate force vector generated by the fin.

        Parameters:
            nu_r (numpy array): Relative velocity [vx, vy, vz, p, q, r] 
                              (m/s for linear, rad/s for angular)
            nu (numpy array): Velocity [vx, vy, vz, p, q, r] 
                              (m/s for linear, rad/s for angular) 

        Returns:
            numpy array: tau vector [Fx, Fy, Fz, Tx, Ty, Tz] (N) and (N*m) in body-fixed frame
        """
            
        U = np.sqrt(nu[0]**2 + nu[1]**2 + nu[2]**2)  # vehicle speed

        # Commands and actual control signals
        n = self.u_actual            # actual propeller revolution (rpm)
        
        # Amplitude saturation of the control signals
        if abs(n) >= self.nMax:
            n = np.sign(n) * self.nMax       
        
        # Propeller coeffs. KT and KQ are computed as a function of advance no.
        # Ja = Va/(n*D_prop) where Va = (1-w)*U = 0.944 * U; Allen et al. (2000)
        D_prop = self.D_prop  # propeller diameter (m)
        t_prop = self.t_prop    # thrust deduction number
        n_rps = n / 60  # propeller revolution (rps) 
        Va = (1-self.w) * U  # advance speed (m/s)

        # Ja_max = 0.944 * 2.5 / (0.14 * 1525/60) = 0.6632
        Ja_max = self.Ja_max

        # Single-screw propeller with 3 blades and blade-area ratio = 0.718.
        # Coffes. are computed using the Matlab MSS toolbox:     
        # >> [KT_0, KQ_0] = wageningen(0,1,0.718,3)
        KT_0 = self.KT_0
        KQ_0 = self.KQ_0
        # >> [KT_max, KQ_max] = wageningen(0.6632,1,0.718,3) 
        KT_max = self.KT_max
        KQ_max = self.KQ_max
        
        # Propeller thrust and propeller-induced roll moment
        # Linear approximations for positive Ja values
        # KT ~= KT_0 + (KT_max-KT_0)/Ja_max * Ja   
        # KQ ~= KQ_0 + (KQ_max-KQ_0)/Ja_max * Ja  
      
        if n_rps > 0:   # forward thrust

            X_prop = self.rho * pow(D_prop,4) * ( 
                KT_0 * abs(n_rps) * n_rps + (KT_max-KT_0)/Ja_max * 
                (Va/D_prop) * abs(n_rps) )        
            K_prop = self.rho * pow(D_prop,5) * (
                KQ_0 * abs(n_rps) * n_rps + (KQ_max-KQ_0)/Ja_max * 
                (Va/D_prop) * abs(n_rps) )           
            
        else:    # reverse thrust (braking)
        
            X_prop = self.rho * pow(D_prop,4) * KT_0 * abs(n_rps) * n_rps 
            K_prop = self.rho * pow(D_prop,5) * KQ_0 * abs(n_rps) * n_rps 

        # Thrust force vector
        # K_Prop scaled down by a factor of 10 to match exp. results
        tau_thrust = np.array([(1-t_prop) * X_prop, 0, 0, K_prop / 10, 0, 0], float)
        return tau_thrust

    def actuate(self, sampleTime ,command):
        # Actuator dynamics
        n_dot = (command - self.u_actual) / self.T_n

        self.u_actual += sampleTime * n_dot
        
        return self.u_actual
        